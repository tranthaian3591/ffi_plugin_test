// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bridge_generated.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Filter {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FilterCopyWith<$Res> {
  factory $FilterCopyWith(Filter value, $Res Function(Filter) then) =
      _$FilterCopyWithImpl<$Res, Filter>;
}

/// @nodoc
class _$FilterCopyWithImpl<$Res, $Val extends Filter>
    implements $FilterCopyWith<$Res> {
  _$FilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Filter_OrCopyWith<$Res> {
  factory _$$Filter_OrCopyWith(
          _$Filter_Or value, $Res Function(_$Filter_Or) then) =
      __$$Filter_OrCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Filter> field0});
}

/// @nodoc
class __$$Filter_OrCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_Or>
    implements _$$Filter_OrCopyWith<$Res> {
  __$$Filter_OrCopyWithImpl(
      _$Filter_Or _value, $Res Function(_$Filter_Or) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Filter_Or(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Filter>,
    ));
  }
}

/// @nodoc

class _$Filter_Or implements Filter_Or {
  const _$Filter_Or(final List<Filter> field0) : _field0 = field0;

  final List<Filter> _field0;
  @override
  List<Filter> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Filter.or(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_Or &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_OrCopyWith<_$Filter_Or> get copyWith =>
      __$$Filter_OrCopyWithImpl<_$Filter_Or>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return or(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return or?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (or != null) {
      return or(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return or(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return or?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (or != null) {
      return or(this);
    }
    return orElse();
  }
}

abstract class Filter_Or implements Filter {
  const factory Filter_Or(final List<Filter> field0) = _$Filter_Or;

  List<Filter> get field0;
  @JsonKey(ignore: true)
  _$$Filter_OrCopyWith<_$Filter_Or> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_AndCopyWith<$Res> {
  factory _$$Filter_AndCopyWith(
          _$Filter_And value, $Res Function(_$Filter_And) then) =
      __$$Filter_AndCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Filter> field0});
}

/// @nodoc
class __$$Filter_AndCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_And>
    implements _$$Filter_AndCopyWith<$Res> {
  __$$Filter_AndCopyWithImpl(
      _$Filter_And _value, $Res Function(_$Filter_And) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Filter_And(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Filter>,
    ));
  }
}

/// @nodoc

class _$Filter_And implements Filter_And {
  const _$Filter_And(final List<Filter> field0) : _field0 = field0;

  final List<Filter> _field0;
  @override
  List<Filter> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Filter.and(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_And &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_AndCopyWith<_$Filter_And> get copyWith =>
      __$$Filter_AndCopyWithImpl<_$Filter_And>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return and(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return and?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (and != null) {
      return and(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return and(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return and?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (and != null) {
      return and(this);
    }
    return orElse();
  }
}

abstract class Filter_And implements Filter {
  const factory Filter_And(final List<Filter> field0) = _$Filter_And;

  List<Filter> get field0;
  @JsonKey(ignore: true)
  _$$Filter_AndCopyWith<_$Filter_And> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_NotCopyWith<$Res> {
  factory _$$Filter_NotCopyWith(
          _$Filter_Not value, $Res Function(_$Filter_Not) then) =
      __$$Filter_NotCopyWithImpl<$Res>;
  @useResult
  $Res call({Filter field0});

  $FilterCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Filter_NotCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_Not>
    implements _$$Filter_NotCopyWith<$Res> {
  __$$Filter_NotCopyWithImpl(
      _$Filter_Not _value, $Res Function(_$Filter_Not) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Filter_Not(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Filter,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $FilterCopyWith<$Res> get field0 {
    return $FilterCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Filter_Not implements Filter_Not {
  const _$Filter_Not(this.field0);

  @override
  final Filter field0;

  @override
  String toString() {
    return 'Filter.not(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_Not &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_NotCopyWith<_$Filter_Not> get copyWith =>
      __$$Filter_NotCopyWithImpl<_$Filter_Not>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return not(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return not?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (not != null) {
      return not(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return not(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return not?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (not != null) {
      return not(this);
    }
    return orElse();
  }
}

abstract class Filter_Not implements Filter {
  const factory Filter_Not(final Filter field0) = _$Filter_Not;

  Filter get field0;
  @JsonKey(ignore: true)
  _$$Filter_NotCopyWith<_$Filter_Not> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_ExistsCopyWith<$Res> {
  factory _$$Filter_ExistsCopyWith(
          _$Filter_Exists value, $Res Function(_$Filter_Exists) then) =
      __$$Filter_ExistsCopyWithImpl<$Res>;
  @useResult
  $Res call({String field});
}

/// @nodoc
class __$$Filter_ExistsCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_Exists>
    implements _$$Filter_ExistsCopyWith<$Res> {
  __$$Filter_ExistsCopyWithImpl(
      _$Filter_Exists _value, $Res Function(_$Filter_Exists) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
  }) {
    return _then(_$Filter_Exists(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_Exists implements Filter_Exists {
  const _$Filter_Exists({required this.field});

  @override
  final String field;

  @override
  String toString() {
    return 'Filter.exists(field: $field)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_Exists &&
            (identical(other.field, field) || other.field == field));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_ExistsCopyWith<_$Filter_Exists> get copyWith =>
      __$$Filter_ExistsCopyWithImpl<_$Filter_Exists>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return exists(field);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return exists?.call(field);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (exists != null) {
      return exists(field);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return exists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return exists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (exists != null) {
      return exists(this);
    }
    return orElse();
  }
}

abstract class Filter_Exists implements Filter {
  const factory Filter_Exists({required final String field}) = _$Filter_Exists;

  String get field;
  @JsonKey(ignore: true)
  _$$Filter_ExistsCopyWith<_$Filter_Exists> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_InValuesCopyWith<$Res> {
  factory _$$Filter_InValuesCopyWith(
          _$Filter_InValues value, $Res Function(_$Filter_InValues) then) =
      __$$Filter_InValuesCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, List<String> values});
}

/// @nodoc
class __$$Filter_InValuesCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_InValues>
    implements _$$Filter_InValuesCopyWith<$Res> {
  __$$Filter_InValuesCopyWithImpl(
      _$Filter_InValues _value, $Res Function(_$Filter_InValues) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? values = null,
  }) {
    return _then(_$Filter_InValues(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      values: null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$Filter_InValues implements Filter_InValues {
  const _$Filter_InValues(
      {required this.field, required final List<String> values})
      : _values = values;

  @override
  final String field;
  final List<String> _values;
  @override
  List<String> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  @override
  String toString() {
    return 'Filter.inValues(field: $field, values: $values)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_InValues &&
            (identical(other.field, field) || other.field == field) &&
            const DeepCollectionEquality().equals(other._values, _values));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, field, const DeepCollectionEquality().hash(_values));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_InValuesCopyWith<_$Filter_InValues> get copyWith =>
      __$$Filter_InValuesCopyWithImpl<_$Filter_InValues>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return inValues(field, values);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return inValues?.call(field, values);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (inValues != null) {
      return inValues(field, values);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return inValues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return inValues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (inValues != null) {
      return inValues(this);
    }
    return orElse();
  }
}

abstract class Filter_InValues implements Filter {
  const factory Filter_InValues(
      {required final String field,
      required final List<String> values}) = _$Filter_InValues;

  String get field;
  List<String> get values;
  @JsonKey(ignore: true)
  _$$Filter_InValuesCopyWith<_$Filter_InValues> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_GreaterThanCopyWith<$Res> {
  factory _$$Filter_GreaterThanCopyWith(_$Filter_GreaterThan value,
          $Res Function(_$Filter_GreaterThan) then) =
      __$$Filter_GreaterThanCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_GreaterThanCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_GreaterThan>
    implements _$$Filter_GreaterThanCopyWith<$Res> {
  __$$Filter_GreaterThanCopyWithImpl(
      _$Filter_GreaterThan _value, $Res Function(_$Filter_GreaterThan) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_GreaterThan(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_GreaterThan implements Filter_GreaterThan {
  const _$Filter_GreaterThan({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.greaterThan(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_GreaterThan &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_GreaterThanCopyWith<_$Filter_GreaterThan> get copyWith =>
      __$$Filter_GreaterThanCopyWithImpl<_$Filter_GreaterThan>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return greaterThan(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return greaterThan?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (greaterThan != null) {
      return greaterThan(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return greaterThan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return greaterThan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (greaterThan != null) {
      return greaterThan(this);
    }
    return orElse();
  }
}

abstract class Filter_GreaterThan implements Filter {
  const factory Filter_GreaterThan(
      {required final String field,
      required final String value}) = _$Filter_GreaterThan;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_GreaterThanCopyWith<_$Filter_GreaterThan> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_GreaterThanOrEqualCopyWith<$Res> {
  factory _$$Filter_GreaterThanOrEqualCopyWith(
          _$Filter_GreaterThanOrEqual value,
          $Res Function(_$Filter_GreaterThanOrEqual) then) =
      __$$Filter_GreaterThanOrEqualCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_GreaterThanOrEqualCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_GreaterThanOrEqual>
    implements _$$Filter_GreaterThanOrEqualCopyWith<$Res> {
  __$$Filter_GreaterThanOrEqualCopyWithImpl(_$Filter_GreaterThanOrEqual _value,
      $Res Function(_$Filter_GreaterThanOrEqual) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_GreaterThanOrEqual(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_GreaterThanOrEqual implements Filter_GreaterThanOrEqual {
  const _$Filter_GreaterThanOrEqual({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.greaterThanOrEqual(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_GreaterThanOrEqual &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_GreaterThanOrEqualCopyWith<_$Filter_GreaterThanOrEqual>
      get copyWith => __$$Filter_GreaterThanOrEqualCopyWithImpl<
          _$Filter_GreaterThanOrEqual>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return greaterThanOrEqual(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return greaterThanOrEqual?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (greaterThanOrEqual != null) {
      return greaterThanOrEqual(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return greaterThanOrEqual(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return greaterThanOrEqual?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (greaterThanOrEqual != null) {
      return greaterThanOrEqual(this);
    }
    return orElse();
  }
}

abstract class Filter_GreaterThanOrEqual implements Filter {
  const factory Filter_GreaterThanOrEqual(
      {required final String field,
      required final String value}) = _$Filter_GreaterThanOrEqual;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_GreaterThanOrEqualCopyWith<_$Filter_GreaterThanOrEqual>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_EqualCopyWith<$Res> {
  factory _$$Filter_EqualCopyWith(
          _$Filter_Equal value, $Res Function(_$Filter_Equal) then) =
      __$$Filter_EqualCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_EqualCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_Equal>
    implements _$$Filter_EqualCopyWith<$Res> {
  __$$Filter_EqualCopyWithImpl(
      _$Filter_Equal _value, $Res Function(_$Filter_Equal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_Equal(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_Equal implements Filter_Equal {
  const _$Filter_Equal({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.equal(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_Equal &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_EqualCopyWith<_$Filter_Equal> get copyWith =>
      __$$Filter_EqualCopyWithImpl<_$Filter_Equal>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return equal(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return equal?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (equal != null) {
      return equal(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return equal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return equal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (equal != null) {
      return equal(this);
    }
    return orElse();
  }
}

abstract class Filter_Equal implements Filter {
  const factory Filter_Equal(
      {required final String field,
      required final String value}) = _$Filter_Equal;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_EqualCopyWith<_$Filter_Equal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_NotEqualCopyWith<$Res> {
  factory _$$Filter_NotEqualCopyWith(
          _$Filter_NotEqual value, $Res Function(_$Filter_NotEqual) then) =
      __$$Filter_NotEqualCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_NotEqualCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_NotEqual>
    implements _$$Filter_NotEqualCopyWith<$Res> {
  __$$Filter_NotEqualCopyWithImpl(
      _$Filter_NotEqual _value, $Res Function(_$Filter_NotEqual) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_NotEqual(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_NotEqual implements Filter_NotEqual {
  const _$Filter_NotEqual({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.notEqual(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_NotEqual &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_NotEqualCopyWith<_$Filter_NotEqual> get copyWith =>
      __$$Filter_NotEqualCopyWithImpl<_$Filter_NotEqual>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return notEqual(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return notEqual?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (notEqual != null) {
      return notEqual(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return notEqual(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return notEqual?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (notEqual != null) {
      return notEqual(this);
    }
    return orElse();
  }
}

abstract class Filter_NotEqual implements Filter {
  const factory Filter_NotEqual(
      {required final String field,
      required final String value}) = _$Filter_NotEqual;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_NotEqualCopyWith<_$Filter_NotEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_LessThanCopyWith<$Res> {
  factory _$$Filter_LessThanCopyWith(
          _$Filter_LessThan value, $Res Function(_$Filter_LessThan) then) =
      __$$Filter_LessThanCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_LessThanCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_LessThan>
    implements _$$Filter_LessThanCopyWith<$Res> {
  __$$Filter_LessThanCopyWithImpl(
      _$Filter_LessThan _value, $Res Function(_$Filter_LessThan) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_LessThan(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_LessThan implements Filter_LessThan {
  const _$Filter_LessThan({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.lessThan(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_LessThan &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_LessThanCopyWith<_$Filter_LessThan> get copyWith =>
      __$$Filter_LessThanCopyWithImpl<_$Filter_LessThan>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return lessThan(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return lessThan?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (lessThan != null) {
      return lessThan(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return lessThan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return lessThan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (lessThan != null) {
      return lessThan(this);
    }
    return orElse();
  }
}

abstract class Filter_LessThan implements Filter {
  const factory Filter_LessThan(
      {required final String field,
      required final String value}) = _$Filter_LessThan;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_LessThanCopyWith<_$Filter_LessThan> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_LessThanOrEqualCopyWith<$Res> {
  factory _$$Filter_LessThanOrEqualCopyWith(_$Filter_LessThanOrEqual value,
          $Res Function(_$Filter_LessThanOrEqual) then) =
      __$$Filter_LessThanOrEqualCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String value});
}

/// @nodoc
class __$$Filter_LessThanOrEqualCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_LessThanOrEqual>
    implements _$$Filter_LessThanOrEqualCopyWith<$Res> {
  __$$Filter_LessThanOrEqualCopyWithImpl(_$Filter_LessThanOrEqual _value,
      $Res Function(_$Filter_LessThanOrEqual) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? value = null,
  }) {
    return _then(_$Filter_LessThanOrEqual(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_LessThanOrEqual implements Filter_LessThanOrEqual {
  const _$Filter_LessThanOrEqual({required this.field, required this.value});

  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'Filter.lessThanOrEqual(field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_LessThanOrEqual &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_LessThanOrEqualCopyWith<_$Filter_LessThanOrEqual> get copyWith =>
      __$$Filter_LessThanOrEqualCopyWithImpl<_$Filter_LessThanOrEqual>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return lessThanOrEqual(field, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return lessThanOrEqual?.call(field, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (lessThanOrEqual != null) {
      return lessThanOrEqual(field, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return lessThanOrEqual(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return lessThanOrEqual?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (lessThanOrEqual != null) {
      return lessThanOrEqual(this);
    }
    return orElse();
  }
}

abstract class Filter_LessThanOrEqual implements Filter {
  const factory Filter_LessThanOrEqual(
      {required final String field,
      required final String value}) = _$Filter_LessThanOrEqual;

  String get field;
  String get value;
  @JsonKey(ignore: true)
  _$$Filter_LessThanOrEqualCopyWith<_$Filter_LessThanOrEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_BetweenCopyWith<$Res> {
  factory _$$Filter_BetweenCopyWith(
          _$Filter_Between value, $Res Function(_$Filter_Between) then) =
      __$$Filter_BetweenCopyWithImpl<$Res>;
  @useResult
  $Res call({String field, String from, String to});
}

/// @nodoc
class __$$Filter_BetweenCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_Between>
    implements _$$Filter_BetweenCopyWith<$Res> {
  __$$Filter_BetweenCopyWithImpl(
      _$Filter_Between _value, $Res Function(_$Filter_Between) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? from = null,
    Object? to = null,
  }) {
    return _then(_$Filter_Between(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      from: null == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as String,
      to: null == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_Between implements Filter_Between {
  const _$Filter_Between(
      {required this.field, required this.from, required this.to});

  @override
  final String field;
  @override
  final String from;
  @override
  final String to;

  @override
  String toString() {
    return 'Filter.between(field: $field, from: $from, to: $to)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_Between &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.to, to) || other.to == to));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field, from, to);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_BetweenCopyWith<_$Filter_Between> get copyWith =>
      __$$Filter_BetweenCopyWithImpl<_$Filter_Between>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return between(field, from, to);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return between?.call(field, from, to);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (between != null) {
      return between(field, from, to);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return between(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return between?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (between != null) {
      return between(this);
    }
    return orElse();
  }
}

abstract class Filter_Between implements Filter {
  const factory Filter_Between(
      {required final String field,
      required final String from,
      required final String to}) = _$Filter_Between;

  String get field;
  String get from;
  String get to;
  @JsonKey(ignore: true)
  _$$Filter_BetweenCopyWith<_$Filter_Between> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_IsNullCopyWith<$Res> {
  factory _$$Filter_IsNullCopyWith(
          _$Filter_IsNull value, $Res Function(_$Filter_IsNull) then) =
      __$$Filter_IsNullCopyWithImpl<$Res>;
  @useResult
  $Res call({String field});
}

/// @nodoc
class __$$Filter_IsNullCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_IsNull>
    implements _$$Filter_IsNullCopyWith<$Res> {
  __$$Filter_IsNullCopyWithImpl(
      _$Filter_IsNull _value, $Res Function(_$Filter_IsNull) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
  }) {
    return _then(_$Filter_IsNull(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_IsNull implements Filter_IsNull {
  const _$Filter_IsNull({required this.field});

  @override
  final String field;

  @override
  String toString() {
    return 'Filter.isNull(field: $field)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_IsNull &&
            (identical(other.field, field) || other.field == field));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_IsNullCopyWith<_$Filter_IsNull> get copyWith =>
      __$$Filter_IsNullCopyWithImpl<_$Filter_IsNull>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return isNull(field);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return isNull?.call(field);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (isNull != null) {
      return isNull(field);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return isNull(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return isNull?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (isNull != null) {
      return isNull(this);
    }
    return orElse();
  }
}

abstract class Filter_IsNull implements Filter {
  const factory Filter_IsNull({required final String field}) = _$Filter_IsNull;

  String get field;
  @JsonKey(ignore: true)
  _$$Filter_IsNullCopyWith<_$Filter_IsNull> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Filter_IsEmptyCopyWith<$Res> {
  factory _$$Filter_IsEmptyCopyWith(
          _$Filter_IsEmpty value, $Res Function(_$Filter_IsEmpty) then) =
      __$$Filter_IsEmptyCopyWithImpl<$Res>;
  @useResult
  $Res call({String field});
}

/// @nodoc
class __$$Filter_IsEmptyCopyWithImpl<$Res>
    extends _$FilterCopyWithImpl<$Res, _$Filter_IsEmpty>
    implements _$$Filter_IsEmptyCopyWith<$Res> {
  __$$Filter_IsEmptyCopyWithImpl(
      _$Filter_IsEmpty _value, $Res Function(_$Filter_IsEmpty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
  }) {
    return _then(_$Filter_IsEmpty(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Filter_IsEmpty implements Filter_IsEmpty {
  const _$Filter_IsEmpty({required this.field});

  @override
  final String field;

  @override
  String toString() {
    return 'Filter.isEmpty(field: $field)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Filter_IsEmpty &&
            (identical(other.field, field) || other.field == field));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Filter_IsEmptyCopyWith<_$Filter_IsEmpty> get copyWith =>
      __$$Filter_IsEmptyCopyWithImpl<_$Filter_IsEmpty>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Filter> field0) or,
    required TResult Function(List<Filter> field0) and,
    required TResult Function(Filter field0) not,
    required TResult Function(String field) exists,
    required TResult Function(String field, List<String> values) inValues,
    required TResult Function(String field, String value) greaterThan,
    required TResult Function(String field, String value) greaterThanOrEqual,
    required TResult Function(String field, String value) equal,
    required TResult Function(String field, String value) notEqual,
    required TResult Function(String field, String value) lessThan,
    required TResult Function(String field, String value) lessThanOrEqual,
    required TResult Function(String field, String from, String to) between,
    required TResult Function(String field) isNull,
    required TResult Function(String field) isEmpty,
  }) {
    return isEmpty(field);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Filter> field0)? or,
    TResult? Function(List<Filter> field0)? and,
    TResult? Function(Filter field0)? not,
    TResult? Function(String field)? exists,
    TResult? Function(String field, List<String> values)? inValues,
    TResult? Function(String field, String value)? greaterThan,
    TResult? Function(String field, String value)? greaterThanOrEqual,
    TResult? Function(String field, String value)? equal,
    TResult? Function(String field, String value)? notEqual,
    TResult? Function(String field, String value)? lessThan,
    TResult? Function(String field, String value)? lessThanOrEqual,
    TResult? Function(String field, String from, String to)? between,
    TResult? Function(String field)? isNull,
    TResult? Function(String field)? isEmpty,
  }) {
    return isEmpty?.call(field);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Filter> field0)? or,
    TResult Function(List<Filter> field0)? and,
    TResult Function(Filter field0)? not,
    TResult Function(String field)? exists,
    TResult Function(String field, List<String> values)? inValues,
    TResult Function(String field, String value)? greaterThan,
    TResult Function(String field, String value)? greaterThanOrEqual,
    TResult Function(String field, String value)? equal,
    TResult Function(String field, String value)? notEqual,
    TResult Function(String field, String value)? lessThan,
    TResult Function(String field, String value)? lessThanOrEqual,
    TResult Function(String field, String from, String to)? between,
    TResult Function(String field)? isNull,
    TResult Function(String field)? isEmpty,
    required TResult orElse(),
  }) {
    if (isEmpty != null) {
      return isEmpty(field);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Filter_Or value) or,
    required TResult Function(Filter_And value) and,
    required TResult Function(Filter_Not value) not,
    required TResult Function(Filter_Exists value) exists,
    required TResult Function(Filter_InValues value) inValues,
    required TResult Function(Filter_GreaterThan value) greaterThan,
    required TResult Function(Filter_GreaterThanOrEqual value)
        greaterThanOrEqual,
    required TResult Function(Filter_Equal value) equal,
    required TResult Function(Filter_NotEqual value) notEqual,
    required TResult Function(Filter_LessThan value) lessThan,
    required TResult Function(Filter_LessThanOrEqual value) lessThanOrEqual,
    required TResult Function(Filter_Between value) between,
    required TResult Function(Filter_IsNull value) isNull,
    required TResult Function(Filter_IsEmpty value) isEmpty,
  }) {
    return isEmpty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Filter_Or value)? or,
    TResult? Function(Filter_And value)? and,
    TResult? Function(Filter_Not value)? not,
    TResult? Function(Filter_Exists value)? exists,
    TResult? Function(Filter_InValues value)? inValues,
    TResult? Function(Filter_GreaterThan value)? greaterThan,
    TResult? Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult? Function(Filter_Equal value)? equal,
    TResult? Function(Filter_NotEqual value)? notEqual,
    TResult? Function(Filter_LessThan value)? lessThan,
    TResult? Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult? Function(Filter_Between value)? between,
    TResult? Function(Filter_IsNull value)? isNull,
    TResult? Function(Filter_IsEmpty value)? isEmpty,
  }) {
    return isEmpty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Filter_Or value)? or,
    TResult Function(Filter_And value)? and,
    TResult Function(Filter_Not value)? not,
    TResult Function(Filter_Exists value)? exists,
    TResult Function(Filter_InValues value)? inValues,
    TResult Function(Filter_GreaterThan value)? greaterThan,
    TResult Function(Filter_GreaterThanOrEqual value)? greaterThanOrEqual,
    TResult Function(Filter_Equal value)? equal,
    TResult Function(Filter_NotEqual value)? notEqual,
    TResult Function(Filter_LessThan value)? lessThan,
    TResult Function(Filter_LessThanOrEqual value)? lessThanOrEqual,
    TResult Function(Filter_Between value)? between,
    TResult Function(Filter_IsNull value)? isNull,
    TResult Function(Filter_IsEmpty value)? isEmpty,
    required TResult orElse(),
  }) {
    if (isEmpty != null) {
      return isEmpty(this);
    }
    return orElse();
  }
}

abstract class Filter_IsEmpty implements Filter {
  const factory Filter_IsEmpty({required final String field}) =
      _$Filter_IsEmpty;

  String get field;
  @JsonKey(ignore: true)
  _$$Filter_IsEmptyCopyWith<_$Filter_IsEmpty> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MimirIndexSettings {
  String? get primaryKey => throw _privateConstructorUsedError;
  List<String>? get searchableFields => throw _privateConstructorUsedError;
  List<String> get filterableFields => throw _privateConstructorUsedError;
  List<String> get sortableFields => throw _privateConstructorUsedError;
  List<String> get rankingRules => throw _privateConstructorUsedError;
  List<String> get stopWords => throw _privateConstructorUsedError;
  List<Synonyms> get synonyms => throw _privateConstructorUsedError;
  bool get typosEnabled => throw _privateConstructorUsedError;
  int get minWordSizeForOneTypo => throw _privateConstructorUsedError;
  int get minWordSizeForTwoTypos => throw _privateConstructorUsedError;
  List<String> get disallowTyposOnWords => throw _privateConstructorUsedError;
  List<String> get disallowTyposOnFields => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MimirIndexSettingsCopyWith<MimirIndexSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MimirIndexSettingsCopyWith<$Res> {
  factory $MimirIndexSettingsCopyWith(
          MimirIndexSettings value, $Res Function(MimirIndexSettings) then) =
      _$MimirIndexSettingsCopyWithImpl<$Res, MimirIndexSettings>;
  @useResult
  $Res call(
      {String? primaryKey,
      List<String>? searchableFields,
      List<String> filterableFields,
      List<String> sortableFields,
      List<String> rankingRules,
      List<String> stopWords,
      List<Synonyms> synonyms,
      bool typosEnabled,
      int minWordSizeForOneTypo,
      int minWordSizeForTwoTypos,
      List<String> disallowTyposOnWords,
      List<String> disallowTyposOnFields});
}

/// @nodoc
class _$MimirIndexSettingsCopyWithImpl<$Res, $Val extends MimirIndexSettings>
    implements $MimirIndexSettingsCopyWith<$Res> {
  _$MimirIndexSettingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? primaryKey = freezed,
    Object? searchableFields = freezed,
    Object? filterableFields = null,
    Object? sortableFields = null,
    Object? rankingRules = null,
    Object? stopWords = null,
    Object? synonyms = null,
    Object? typosEnabled = null,
    Object? minWordSizeForOneTypo = null,
    Object? minWordSizeForTwoTypos = null,
    Object? disallowTyposOnWords = null,
    Object? disallowTyposOnFields = null,
  }) {
    return _then(_value.copyWith(
      primaryKey: freezed == primaryKey
          ? _value.primaryKey
          : primaryKey // ignore: cast_nullable_to_non_nullable
              as String?,
      searchableFields: freezed == searchableFields
          ? _value.searchableFields
          : searchableFields // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      filterableFields: null == filterableFields
          ? _value.filterableFields
          : filterableFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sortableFields: null == sortableFields
          ? _value.sortableFields
          : sortableFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
      rankingRules: null == rankingRules
          ? _value.rankingRules
          : rankingRules // ignore: cast_nullable_to_non_nullable
              as List<String>,
      stopWords: null == stopWords
          ? _value.stopWords
          : stopWords // ignore: cast_nullable_to_non_nullable
              as List<String>,
      synonyms: null == synonyms
          ? _value.synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<Synonyms>,
      typosEnabled: null == typosEnabled
          ? _value.typosEnabled
          : typosEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      minWordSizeForOneTypo: null == minWordSizeForOneTypo
          ? _value.minWordSizeForOneTypo
          : minWordSizeForOneTypo // ignore: cast_nullable_to_non_nullable
              as int,
      minWordSizeForTwoTypos: null == minWordSizeForTwoTypos
          ? _value.minWordSizeForTwoTypos
          : minWordSizeForTwoTypos // ignore: cast_nullable_to_non_nullable
              as int,
      disallowTyposOnWords: null == disallowTyposOnWords
          ? _value.disallowTyposOnWords
          : disallowTyposOnWords // ignore: cast_nullable_to_non_nullable
              as List<String>,
      disallowTyposOnFields: null == disallowTyposOnFields
          ? _value.disallowTyposOnFields
          : disallowTyposOnFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MimirIndexSettingsCopyWith<$Res>
    implements $MimirIndexSettingsCopyWith<$Res> {
  factory _$$_MimirIndexSettingsCopyWith(_$_MimirIndexSettings value,
          $Res Function(_$_MimirIndexSettings) then) =
      __$$_MimirIndexSettingsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? primaryKey,
      List<String>? searchableFields,
      List<String> filterableFields,
      List<String> sortableFields,
      List<String> rankingRules,
      List<String> stopWords,
      List<Synonyms> synonyms,
      bool typosEnabled,
      int minWordSizeForOneTypo,
      int minWordSizeForTwoTypos,
      List<String> disallowTyposOnWords,
      List<String> disallowTyposOnFields});
}

/// @nodoc
class __$$_MimirIndexSettingsCopyWithImpl<$Res>
    extends _$MimirIndexSettingsCopyWithImpl<$Res, _$_MimirIndexSettings>
    implements _$$_MimirIndexSettingsCopyWith<$Res> {
  __$$_MimirIndexSettingsCopyWithImpl(
      _$_MimirIndexSettings _value, $Res Function(_$_MimirIndexSettings) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? primaryKey = freezed,
    Object? searchableFields = freezed,
    Object? filterableFields = null,
    Object? sortableFields = null,
    Object? rankingRules = null,
    Object? stopWords = null,
    Object? synonyms = null,
    Object? typosEnabled = null,
    Object? minWordSizeForOneTypo = null,
    Object? minWordSizeForTwoTypos = null,
    Object? disallowTyposOnWords = null,
    Object? disallowTyposOnFields = null,
  }) {
    return _then(_$_MimirIndexSettings(
      primaryKey: freezed == primaryKey
          ? _value.primaryKey
          : primaryKey // ignore: cast_nullable_to_non_nullable
              as String?,
      searchableFields: freezed == searchableFields
          ? _value._searchableFields
          : searchableFields // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      filterableFields: null == filterableFields
          ? _value._filterableFields
          : filterableFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sortableFields: null == sortableFields
          ? _value._sortableFields
          : sortableFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
      rankingRules: null == rankingRules
          ? _value._rankingRules
          : rankingRules // ignore: cast_nullable_to_non_nullable
              as List<String>,
      stopWords: null == stopWords
          ? _value._stopWords
          : stopWords // ignore: cast_nullable_to_non_nullable
              as List<String>,
      synonyms: null == synonyms
          ? _value._synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<Synonyms>,
      typosEnabled: null == typosEnabled
          ? _value.typosEnabled
          : typosEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      minWordSizeForOneTypo: null == minWordSizeForOneTypo
          ? _value.minWordSizeForOneTypo
          : minWordSizeForOneTypo // ignore: cast_nullable_to_non_nullable
              as int,
      minWordSizeForTwoTypos: null == minWordSizeForTwoTypos
          ? _value.minWordSizeForTwoTypos
          : minWordSizeForTwoTypos // ignore: cast_nullable_to_non_nullable
              as int,
      disallowTyposOnWords: null == disallowTyposOnWords
          ? _value._disallowTyposOnWords
          : disallowTyposOnWords // ignore: cast_nullable_to_non_nullable
              as List<String>,
      disallowTyposOnFields: null == disallowTyposOnFields
          ? _value._disallowTyposOnFields
          : disallowTyposOnFields // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$_MimirIndexSettings implements _MimirIndexSettings {
  const _$_MimirIndexSettings(
      {this.primaryKey,
      final List<String>? searchableFields,
      required final List<String> filterableFields,
      required final List<String> sortableFields,
      required final List<String> rankingRules,
      required final List<String> stopWords,
      required final List<Synonyms> synonyms,
      required this.typosEnabled,
      required this.minWordSizeForOneTypo,
      required this.minWordSizeForTwoTypos,
      required final List<String> disallowTyposOnWords,
      required final List<String> disallowTyposOnFields})
      : _searchableFields = searchableFields,
        _filterableFields = filterableFields,
        _sortableFields = sortableFields,
        _rankingRules = rankingRules,
        _stopWords = stopWords,
        _synonyms = synonyms,
        _disallowTyposOnWords = disallowTyposOnWords,
        _disallowTyposOnFields = disallowTyposOnFields;

  @override
  final String? primaryKey;
  final List<String>? _searchableFields;
  @override
  List<String>? get searchableFields {
    final value = _searchableFields;
    if (value == null) return null;
    if (_searchableFields is EqualUnmodifiableListView)
      return _searchableFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String> _filterableFields;
  @override
  List<String> get filterableFields {
    if (_filterableFields is EqualUnmodifiableListView)
      return _filterableFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterableFields);
  }

  final List<String> _sortableFields;
  @override
  List<String> get sortableFields {
    if (_sortableFields is EqualUnmodifiableListView) return _sortableFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sortableFields);
  }

  final List<String> _rankingRules;
  @override
  List<String> get rankingRules {
    if (_rankingRules is EqualUnmodifiableListView) return _rankingRules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_rankingRules);
  }

  final List<String> _stopWords;
  @override
  List<String> get stopWords {
    if (_stopWords is EqualUnmodifiableListView) return _stopWords;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_stopWords);
  }

  final List<Synonyms> _synonyms;
  @override
  List<Synonyms> get synonyms {
    if (_synonyms is EqualUnmodifiableListView) return _synonyms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_synonyms);
  }

  @override
  final bool typosEnabled;
  @override
  final int minWordSizeForOneTypo;
  @override
  final int minWordSizeForTwoTypos;
  final List<String> _disallowTyposOnWords;
  @override
  List<String> get disallowTyposOnWords {
    if (_disallowTyposOnWords is EqualUnmodifiableListView)
      return _disallowTyposOnWords;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_disallowTyposOnWords);
  }

  final List<String> _disallowTyposOnFields;
  @override
  List<String> get disallowTyposOnFields {
    if (_disallowTyposOnFields is EqualUnmodifiableListView)
      return _disallowTyposOnFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_disallowTyposOnFields);
  }

  @override
  String toString() {
    return 'MimirIndexSettings(primaryKey: $primaryKey, searchableFields: $searchableFields, filterableFields: $filterableFields, sortableFields: $sortableFields, rankingRules: $rankingRules, stopWords: $stopWords, synonyms: $synonyms, typosEnabled: $typosEnabled, minWordSizeForOneTypo: $minWordSizeForOneTypo, minWordSizeForTwoTypos: $minWordSizeForTwoTypos, disallowTyposOnWords: $disallowTyposOnWords, disallowTyposOnFields: $disallowTyposOnFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MimirIndexSettings &&
            (identical(other.primaryKey, primaryKey) ||
                other.primaryKey == primaryKey) &&
            const DeepCollectionEquality()
                .equals(other._searchableFields, _searchableFields) &&
            const DeepCollectionEquality()
                .equals(other._filterableFields, _filterableFields) &&
            const DeepCollectionEquality()
                .equals(other._sortableFields, _sortableFields) &&
            const DeepCollectionEquality()
                .equals(other._rankingRules, _rankingRules) &&
            const DeepCollectionEquality()
                .equals(other._stopWords, _stopWords) &&
            const DeepCollectionEquality().equals(other._synonyms, _synonyms) &&
            (identical(other.typosEnabled, typosEnabled) ||
                other.typosEnabled == typosEnabled) &&
            (identical(other.minWordSizeForOneTypo, minWordSizeForOneTypo) ||
                other.minWordSizeForOneTypo == minWordSizeForOneTypo) &&
            (identical(other.minWordSizeForTwoTypos, minWordSizeForTwoTypos) ||
                other.minWordSizeForTwoTypos == minWordSizeForTwoTypos) &&
            const DeepCollectionEquality()
                .equals(other._disallowTyposOnWords, _disallowTyposOnWords) &&
            const DeepCollectionEquality()
                .equals(other._disallowTyposOnFields, _disallowTyposOnFields));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      primaryKey,
      const DeepCollectionEquality().hash(_searchableFields),
      const DeepCollectionEquality().hash(_filterableFields),
      const DeepCollectionEquality().hash(_sortableFields),
      const DeepCollectionEquality().hash(_rankingRules),
      const DeepCollectionEquality().hash(_stopWords),
      const DeepCollectionEquality().hash(_synonyms),
      typosEnabled,
      minWordSizeForOneTypo,
      minWordSizeForTwoTypos,
      const DeepCollectionEquality().hash(_disallowTyposOnWords),
      const DeepCollectionEquality().hash(_disallowTyposOnFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MimirIndexSettingsCopyWith<_$_MimirIndexSettings> get copyWith =>
      __$$_MimirIndexSettingsCopyWithImpl<_$_MimirIndexSettings>(
          this, _$identity);
}

abstract class _MimirIndexSettings implements MimirIndexSettings {
  const factory _MimirIndexSettings(
          {final String? primaryKey,
          final List<String>? searchableFields,
          required final List<String> filterableFields,
          required final List<String> sortableFields,
          required final List<String> rankingRules,
          required final List<String> stopWords,
          required final List<Synonyms> synonyms,
          required final bool typosEnabled,
          required final int minWordSizeForOneTypo,
          required final int minWordSizeForTwoTypos,
          required final List<String> disallowTyposOnWords,
          required final List<String> disallowTyposOnFields}) =
      _$_MimirIndexSettings;

  @override
  String? get primaryKey;
  @override
  List<String>? get searchableFields;
  @override
  List<String> get filterableFields;
  @override
  List<String> get sortableFields;
  @override
  List<String> get rankingRules;
  @override
  List<String> get stopWords;
  @override
  List<Synonyms> get synonyms;
  @override
  bool get typosEnabled;
  @override
  int get minWordSizeForOneTypo;
  @override
  int get minWordSizeForTwoTypos;
  @override
  List<String> get disallowTyposOnWords;
  @override
  List<String> get disallowTyposOnFields;
  @override
  @JsonKey(ignore: true)
  _$$_MimirIndexSettingsCopyWith<_$_MimirIndexSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SortBy {
  String get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) asc,
    required TResult Function(String field0) desc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? asc,
    TResult? Function(String field0)? desc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? asc,
    TResult Function(String field0)? desc,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SortBy_Asc value) asc,
    required TResult Function(SortBy_Desc value) desc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SortBy_Asc value)? asc,
    TResult? Function(SortBy_Desc value)? desc,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SortBy_Asc value)? asc,
    TResult Function(SortBy_Desc value)? desc,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SortByCopyWith<SortBy> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SortByCopyWith<$Res> {
  factory $SortByCopyWith(SortBy value, $Res Function(SortBy) then) =
      _$SortByCopyWithImpl<$Res, SortBy>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$SortByCopyWithImpl<$Res, $Val extends SortBy>
    implements $SortByCopyWith<$Res> {
  _$SortByCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SortBy_AscCopyWith<$Res> implements $SortByCopyWith<$Res> {
  factory _$$SortBy_AscCopyWith(
          _$SortBy_Asc value, $Res Function(_$SortBy_Asc) then) =
      __$$SortBy_AscCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SortBy_AscCopyWithImpl<$Res>
    extends _$SortByCopyWithImpl<$Res, _$SortBy_Asc>
    implements _$$SortBy_AscCopyWith<$Res> {
  __$$SortBy_AscCopyWithImpl(
      _$SortBy_Asc _value, $Res Function(_$SortBy_Asc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SortBy_Asc(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SortBy_Asc implements SortBy_Asc {
  const _$SortBy_Asc(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SortBy.asc(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SortBy_Asc &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SortBy_AscCopyWith<_$SortBy_Asc> get copyWith =>
      __$$SortBy_AscCopyWithImpl<_$SortBy_Asc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) asc,
    required TResult Function(String field0) desc,
  }) {
    return asc(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? asc,
    TResult? Function(String field0)? desc,
  }) {
    return asc?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? asc,
    TResult Function(String field0)? desc,
    required TResult orElse(),
  }) {
    if (asc != null) {
      return asc(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SortBy_Asc value) asc,
    required TResult Function(SortBy_Desc value) desc,
  }) {
    return asc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SortBy_Asc value)? asc,
    TResult? Function(SortBy_Desc value)? desc,
  }) {
    return asc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SortBy_Asc value)? asc,
    TResult Function(SortBy_Desc value)? desc,
    required TResult orElse(),
  }) {
    if (asc != null) {
      return asc(this);
    }
    return orElse();
  }
}

abstract class SortBy_Asc implements SortBy {
  const factory SortBy_Asc(final String field0) = _$SortBy_Asc;

  @override
  String get field0;
  @override
  @JsonKey(ignore: true)
  _$$SortBy_AscCopyWith<_$SortBy_Asc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SortBy_DescCopyWith<$Res> implements $SortByCopyWith<$Res> {
  factory _$$SortBy_DescCopyWith(
          _$SortBy_Desc value, $Res Function(_$SortBy_Desc) then) =
      __$$SortBy_DescCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$SortBy_DescCopyWithImpl<$Res>
    extends _$SortByCopyWithImpl<$Res, _$SortBy_Desc>
    implements _$$SortBy_DescCopyWith<$Res> {
  __$$SortBy_DescCopyWithImpl(
      _$SortBy_Desc _value, $Res Function(_$SortBy_Desc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SortBy_Desc(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SortBy_Desc implements SortBy_Desc {
  const _$SortBy_Desc(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'SortBy.desc(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SortBy_Desc &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SortBy_DescCopyWith<_$SortBy_Desc> get copyWith =>
      __$$SortBy_DescCopyWithImpl<_$SortBy_Desc>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) asc,
    required TResult Function(String field0) desc,
  }) {
    return desc(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? asc,
    TResult? Function(String field0)? desc,
  }) {
    return desc?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? asc,
    TResult Function(String field0)? desc,
    required TResult orElse(),
  }) {
    if (desc != null) {
      return desc(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SortBy_Asc value) asc,
    required TResult Function(SortBy_Desc value) desc,
  }) {
    return desc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SortBy_Asc value)? asc,
    TResult? Function(SortBy_Desc value)? desc,
  }) {
    return desc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SortBy_Asc value)? asc,
    TResult Function(SortBy_Desc value)? desc,
    required TResult orElse(),
  }) {
    if (desc != null) {
      return desc(this);
    }
    return orElse();
  }
}

abstract class SortBy_Desc implements SortBy {
  const factory SortBy_Desc(final String field0) = _$SortBy_Desc;

  @override
  String get field0;
  @override
  @JsonKey(ignore: true)
  _$$SortBy_DescCopyWith<_$SortBy_Desc> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Synonyms {
  String get word => throw _privateConstructorUsedError;
  List<String> get synonyms => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SynonymsCopyWith<Synonyms> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SynonymsCopyWith<$Res> {
  factory $SynonymsCopyWith(Synonyms value, $Res Function(Synonyms) then) =
      _$SynonymsCopyWithImpl<$Res, Synonyms>;
  @useResult
  $Res call({String word, List<String> synonyms});
}

/// @nodoc
class _$SynonymsCopyWithImpl<$Res, $Val extends Synonyms>
    implements $SynonymsCopyWith<$Res> {
  _$SynonymsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
    Object? synonyms = null,
  }) {
    return _then(_value.copyWith(
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as String,
      synonyms: null == synonyms
          ? _value.synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SynonymsCopyWith<$Res> implements $SynonymsCopyWith<$Res> {
  factory _$$_SynonymsCopyWith(
          _$_Synonyms value, $Res Function(_$_Synonyms) then) =
      __$$_SynonymsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String word, List<String> synonyms});
}

/// @nodoc
class __$$_SynonymsCopyWithImpl<$Res>
    extends _$SynonymsCopyWithImpl<$Res, _$_Synonyms>
    implements _$$_SynonymsCopyWith<$Res> {
  __$$_SynonymsCopyWithImpl(
      _$_Synonyms _value, $Res Function(_$_Synonyms) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
    Object? synonyms = null,
  }) {
    return _then(_$_Synonyms(
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as String,
      synonyms: null == synonyms
          ? _value._synonyms
          : synonyms // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$_Synonyms implements _Synonyms {
  const _$_Synonyms({required this.word, required final List<String> synonyms})
      : _synonyms = synonyms;

  @override
  final String word;
  final List<String> _synonyms;
  @override
  List<String> get synonyms {
    if (_synonyms is EqualUnmodifiableListView) return _synonyms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_synonyms);
  }

  @override
  String toString() {
    return 'Synonyms(word: $word, synonyms: $synonyms)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Synonyms &&
            (identical(other.word, word) || other.word == word) &&
            const DeepCollectionEquality().equals(other._synonyms, _synonyms));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, word, const DeepCollectionEquality().hash(_synonyms));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SynonymsCopyWith<_$_Synonyms> get copyWith =>
      __$$_SynonymsCopyWithImpl<_$_Synonyms>(this, _$identity);
}

abstract class _Synonyms implements Synonyms {
  const factory _Synonyms(
      {required final String word,
      required final List<String> synonyms}) = _$_Synonyms;

  @override
  String get word;
  @override
  List<String> get synonyms;
  @override
  @JsonKey(ignore: true)
  _$$_SynonymsCopyWith<_$_Synonyms> get copyWith =>
      throw _privateConstructorUsedError;
}
