#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.78.0.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

// Section: wire functions

fn wire_ensure_instance_initialized_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    tmp_dir: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "ensure_instance_initialized",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_tmp_dir = tmp_dir.wire2api();
            move |task_callback| ensure_instance_initialized(api_instance_dir, api_tmp_dir)
        },
    )
}
fn wire_ensure_index_initialized_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "ensure_index_initialized",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            move |task_callback| ensure_index_initialized(api_instance_dir, api_index_name)
        },
    )
}
fn wire_add_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    documents: impl Wire2Api<Vec<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "add_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_documents = documents.wire2api();
            move |task_callback| add_documents(api_instance_dir, api_index_name, api_documents)
        },
    )
}
fn wire_delete_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    document_ids: impl Wire2Api<Vec<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "delete_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_document_ids = document_ids.wire2api();
            move |task_callback| {
                delete_documents(api_instance_dir, api_index_name, api_document_ids)
            }
        },
    )
}
fn wire_delete_all_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "delete_all_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            move |task_callback| delete_all_documents(api_instance_dir, api_index_name)
        },
    )
}
fn wire_set_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    documents: impl Wire2Api<Vec<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_documents = documents.wire2api();
            move |task_callback| set_documents(api_instance_dir, api_index_name, api_documents)
        },
    )
}
fn wire_get_document_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    document_id: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_document",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_document_id = document_id.wire2api();
            move |task_callback| get_document(api_instance_dir, api_index_name, api_document_id)
        },
    )
}
fn wire_get_all_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_all_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            move |task_callback| get_all_documents(api_instance_dir, api_index_name)
        },
    )
}
fn wire_search_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    query: impl Wire2Api<Option<String>> + UnwindSafe,
    limit: impl Wire2Api<Option<u32>> + UnwindSafe,
    offset: impl Wire2Api<Option<u32>> + UnwindSafe,
    sort_criteria: impl Wire2Api<Option<Vec<SortBy>>> + UnwindSafe,
    filter: impl Wire2Api<Option<Filter>> + UnwindSafe,
    matching_strategy: impl Wire2Api<Option<TermsMatchingStrategy>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "search_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_query = query.wire2api();
            let api_limit = limit.wire2api();
            let api_offset = offset.wire2api();
            let api_sort_criteria = sort_criteria.wire2api();
            let api_filter = filter.wire2api();
            let api_matching_strategy = matching_strategy.wire2api();
            move |task_callback| {
                search_documents(
                    api_instance_dir,
                    api_index_name,
                    api_query,
                    api_limit,
                    api_offset,
                    api_sort_criteria,
                    api_filter,
                    api_matching_strategy,
                )
            }
        },
    )
}
fn wire_number_of_documents_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "number_of_documents",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            move |task_callback| number_of_documents(api_instance_dir, api_index_name)
        },
    )
}
fn wire_get_settings_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_settings",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            move |task_callback| get_settings(api_instance_dir, api_index_name)
        },
    )
}
fn wire_set_settings_impl(
    port_: MessagePort,
    instance_dir: impl Wire2Api<String> + UnwindSafe,
    index_name: impl Wire2Api<String> + UnwindSafe,
    settings: impl Wire2Api<MimirIndexSettings> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_settings",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_instance_dir = instance_dir.wire2api();
            let api_index_name = index_name.wire2api();
            let api_settings = settings.wire2api();
            move |task_callback| set_settings(api_instance_dir, api_index_name, api_settings)
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}

impl Wire2Api<TermsMatchingStrategy> for i32 {
    fn wire2api(self) -> TermsMatchingStrategy {
        match self {
            0 => TermsMatchingStrategy::Last,
            1 => TermsMatchingStrategy::All,
            _ => unreachable!("Invalid variant for TermsMatchingStrategy: {}", self),
        }
    }
}
impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

// Section: impl IntoDart

impl support::IntoDart for MimirIndexSettings {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.primary_key.into_dart(),
            self.searchable_fields.into_dart(),
            self.filterable_fields.into_dart(),
            self.sortable_fields.into_dart(),
            self.ranking_rules.into_dart(),
            self.stop_words.into_dart(),
            self.synonyms.into_dart(),
            self.typos_enabled.into_dart(),
            self.min_word_size_for_one_typo.into_dart(),
            self.min_word_size_for_two_typos.into_dart(),
            self.disallow_typos_on_words.into_dart(),
            self.disallow_typos_on_fields.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for MimirIndexSettings {}

impl support::IntoDart for Synonyms {
    fn into_dart(self) -> support::DartAbi {
        vec![self.word.into_dart(), self.synonyms.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Synonyms {}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    use super::*;
    // Section: wire functions

    #[wasm_bindgen]
    pub fn wire_ensure_instance_initialized(
        port_: MessagePort,
        instance_dir: String,
        tmp_dir: Option<String>,
    ) {
        wire_ensure_instance_initialized_impl(port_, instance_dir, tmp_dir)
    }

    #[wasm_bindgen]
    pub fn wire_ensure_index_initialized(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
    ) {
        wire_ensure_index_initialized_impl(port_, instance_dir, index_name)
    }

    #[wasm_bindgen]
    pub fn wire_add_documents(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        documents: JsValue,
    ) {
        wire_add_documents_impl(port_, instance_dir, index_name, documents)
    }

    #[wasm_bindgen]
    pub fn wire_delete_documents(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        document_ids: JsValue,
    ) {
        wire_delete_documents_impl(port_, instance_dir, index_name, document_ids)
    }

    #[wasm_bindgen]
    pub fn wire_delete_all_documents(port_: MessagePort, instance_dir: String, index_name: String) {
        wire_delete_all_documents_impl(port_, instance_dir, index_name)
    }

    #[wasm_bindgen]
    pub fn wire_set_documents(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        documents: JsValue,
    ) {
        wire_set_documents_impl(port_, instance_dir, index_name, documents)
    }

    #[wasm_bindgen]
    pub fn wire_get_document(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        document_id: String,
    ) {
        wire_get_document_impl(port_, instance_dir, index_name, document_id)
    }

    #[wasm_bindgen]
    pub fn wire_get_all_documents(port_: MessagePort, instance_dir: String, index_name: String) {
        wire_get_all_documents_impl(port_, instance_dir, index_name)
    }

    #[wasm_bindgen]
    pub fn wire_search_documents(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        query: Option<String>,
        limit: JsValue,
        offset: JsValue,
        sort_criteria: JsValue,
        filter: JsValue,
        matching_strategy: JsValue,
    ) {
        wire_search_documents_impl(
            port_,
            instance_dir,
            index_name,
            query,
            limit,
            offset,
            sort_criteria,
            filter,
            matching_strategy,
        )
    }

    #[wasm_bindgen]
    pub fn wire_number_of_documents(port_: MessagePort, instance_dir: String, index_name: String) {
        wire_number_of_documents_impl(port_, instance_dir, index_name)
    }

    #[wasm_bindgen]
    pub fn wire_get_settings(port_: MessagePort, instance_dir: String, index_name: String) {
        wire_get_settings_impl(port_, instance_dir, index_name)
    }

    #[wasm_bindgen]
    pub fn wire_set_settings(
        port_: MessagePort,
        instance_dir: String,
        index_name: String,
        settings: JsValue,
    ) {
        wire_set_settings_impl(port_, instance_dir, index_name, settings)
    }

    // Section: allocate functions

    // Section: related functions

    // Section: impl Wire2Api

    impl Wire2Api<String> for String {
        fn wire2api(self) -> String {
            self
        }
    }
    impl Wire2Api<Vec<String>> for JsValue {
        fn wire2api(self) -> Vec<String> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }

    impl Wire2Api<Filter> for JsValue {
        fn wire2api(self) -> Filter {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => Filter::Or(self_.get(1).wire2api()),
                1 => Filter::And(self_.get(1).wire2api()),
                2 => Filter::Not(self_.get(1).wire2api()),
                3 => Filter::Exists {
                    field: self_.get(1).wire2api(),
                },
                4 => Filter::InValues {
                    field: self_.get(1).wire2api(),
                    values: self_.get(2).wire2api(),
                },
                5 => Filter::GreaterThan {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                6 => Filter::GreaterThanOrEqual {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                7 => Filter::Equal {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                8 => Filter::NotEqual {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                9 => Filter::LessThan {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                10 => Filter::LessThanOrEqual {
                    field: self_.get(1).wire2api(),
                    value: self_.get(2).wire2api(),
                },
                11 => Filter::Between {
                    field: self_.get(1).wire2api(),
                    from: self_.get(2).wire2api(),
                    to: self_.get(3).wire2api(),
                },
                12 => Filter::IsNull {
                    field: self_.get(1).wire2api(),
                },
                13 => Filter::IsEmpty {
                    field: self_.get(1).wire2api(),
                },
                _ => unreachable!(),
            }
        }
    }

    impl Wire2Api<Vec<Filter>> for JsValue {
        fn wire2api(self) -> Vec<Filter> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }
    impl Wire2Api<Vec<SortBy>> for JsValue {
        fn wire2api(self) -> Vec<SortBy> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }
    impl Wire2Api<Vec<Synonyms>> for JsValue {
        fn wire2api(self) -> Vec<Synonyms> {
            self.dyn_into::<JsArray>()
                .unwrap()
                .iter()
                .map(Wire2Api::wire2api)
                .collect()
        }
    }
    impl Wire2Api<MimirIndexSettings> for JsValue {
        fn wire2api(self) -> MimirIndexSettings {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                12,
                "Expected 12 elements, got {}",
                self_.length()
            );
            MimirIndexSettings {
                primary_key: self_.get(0).wire2api(),
                searchable_fields: self_.get(1).wire2api(),
                filterable_fields: self_.get(2).wire2api(),
                sortable_fields: self_.get(3).wire2api(),
                ranking_rules: self_.get(4).wire2api(),
                stop_words: self_.get(5).wire2api(),
                synonyms: self_.get(6).wire2api(),
                typos_enabled: self_.get(7).wire2api(),
                min_word_size_for_one_typo: self_.get(8).wire2api(),
                min_word_size_for_two_typos: self_.get(9).wire2api(),
                disallow_typos_on_words: self_.get(10).wire2api(),
                disallow_typos_on_fields: self_.get(11).wire2api(),
            }
        }
    }
    impl Wire2Api<Option<String>> for Option<String> {
        fn wire2api(self) -> Option<String> {
            self.map(Wire2Api::wire2api)
        }
    }
    impl Wire2Api<Option<Vec<String>>> for Option<JsValue> {
        fn wire2api(self) -> Option<Vec<String>> {
            self.map(Wire2Api::wire2api)
        }
    }
    impl Wire2Api<Option<Filter>> for JsValue {
        fn wire2api(self) -> Option<Filter> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }

    impl Wire2Api<Option<Vec<SortBy>>> for JsValue {
        fn wire2api(self) -> Option<Vec<SortBy>> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<SortBy> for JsValue {
        fn wire2api(self) -> SortBy {
            let self_ = self.unchecked_into::<JsArray>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => SortBy::Asc(self_.get(1).wire2api()),
                1 => SortBy::Desc(self_.get(1).wire2api()),
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<Synonyms> for JsValue {
        fn wire2api(self) -> Synonyms {
            let self_ = self.dyn_into::<JsArray>().unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            Synonyms {
                word: self_.get(0).wire2api(),
                synonyms: self_.get(1).wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<u8>> for Box<[u8]> {
        fn wire2api(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    // Section: impl Wire2Api for JsValue

    impl Wire2Api<String> for JsValue {
        fn wire2api(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl Wire2Api<bool> for JsValue {
        fn wire2api(self) -> bool {
            self.is_truthy()
        }
    }
    impl Wire2Api<Box<Filter>> for JsValue {
        fn wire2api(self) -> Box<Filter> {
            Box::new(self.wire2api())
        }
    }
    impl Wire2Api<i32> for JsValue {
        fn wire2api(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<Option<String>> for JsValue {
        fn wire2api(self) -> Option<String> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<Vec<String>>> for JsValue {
        fn wire2api(self) -> Option<Vec<String>> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<TermsMatchingStrategy>> for JsValue {
        fn wire2api(self) -> Option<TermsMatchingStrategy> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<Option<u32>> for JsValue {
        fn wire2api(self) -> Option<u32> {
            (!self.is_undefined() && !self.is_null()).then(|| self.wire2api())
        }
    }
    impl Wire2Api<TermsMatchingStrategy> for JsValue {
        fn wire2api(self) -> TermsMatchingStrategy {
            (self.unchecked_into_f64() as i32).wire2api()
        }
    }
    impl Wire2Api<u32> for JsValue {
        fn wire2api(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<u8> for JsValue {
        fn wire2api(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl Wire2Api<Vec<u8>> for JsValue {
        fn wire2api(self) -> Vec<u8> {
            self.unchecked_into::<js_sys::Uint8Array>().to_vec().into()
        }
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;

#[cfg(not(target_family = "wasm"))]
mod io {
    use super::*;
    // Section: wire functions

    #[no_mangle]
    pub extern "C" fn wire_ensure_instance_initialized(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        tmp_dir: *mut wire_uint_8_list,
    ) {
        wire_ensure_instance_initialized_impl(port_, instance_dir, tmp_dir)
    }

    #[no_mangle]
    pub extern "C" fn wire_ensure_index_initialized(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
    ) {
        wire_ensure_index_initialized_impl(port_, instance_dir, index_name)
    }

    #[no_mangle]
    pub extern "C" fn wire_add_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        documents: *mut wire_StringList,
    ) {
        wire_add_documents_impl(port_, instance_dir, index_name, documents)
    }

    #[no_mangle]
    pub extern "C" fn wire_delete_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        document_ids: *mut wire_StringList,
    ) {
        wire_delete_documents_impl(port_, instance_dir, index_name, document_ids)
    }

    #[no_mangle]
    pub extern "C" fn wire_delete_all_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
    ) {
        wire_delete_all_documents_impl(port_, instance_dir, index_name)
    }

    #[no_mangle]
    pub extern "C" fn wire_set_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        documents: *mut wire_StringList,
    ) {
        wire_set_documents_impl(port_, instance_dir, index_name, documents)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_document(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        document_id: *mut wire_uint_8_list,
    ) {
        wire_get_document_impl(port_, instance_dir, index_name, document_id)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_all_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
    ) {
        wire_get_all_documents_impl(port_, instance_dir, index_name)
    }

    #[no_mangle]
    pub extern "C" fn wire_search_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        query: *mut wire_uint_8_list,
        limit: *mut u32,
        offset: *mut u32,
        sort_criteria: *mut wire_list_sort_by,
        filter: *mut wire_Filter,
        matching_strategy: *mut i32,
    ) {
        wire_search_documents_impl(
            port_,
            instance_dir,
            index_name,
            query,
            limit,
            offset,
            sort_criteria,
            filter,
            matching_strategy,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_number_of_documents(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
    ) {
        wire_number_of_documents_impl(port_, instance_dir, index_name)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_settings(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
    ) {
        wire_get_settings_impl(port_, instance_dir, index_name)
    }

    #[no_mangle]
    pub extern "C" fn wire_set_settings(
        port_: i64,
        instance_dir: *mut wire_uint_8_list,
        index_name: *mut wire_uint_8_list,
        settings: *mut wire_MimirIndexSettings,
    ) {
        wire_set_settings_impl(port_, instance_dir, index_name, settings)
    }

    // Section: allocate functions

    #[no_mangle]
    pub extern "C" fn new_StringList_0(len: i32) -> *mut wire_StringList {
        let wrap = wire_StringList {
            ptr: support::new_leak_vec_ptr(<*mut wire_uint_8_list>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_filter_0() -> *mut wire_Filter {
        support::new_leak_box_ptr(wire_Filter::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_mimir_index_settings_0() -> *mut wire_MimirIndexSettings {
        support::new_leak_box_ptr(wire_MimirIndexSettings::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_terms_matching_strategy_0(value: i32) -> *mut i32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u32_0(value: u32) -> *mut u32 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_filter_0() -> *mut wire_Filter {
        support::new_leak_box_ptr(wire_Filter::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_list_filter_0(len: i32) -> *mut wire_list_filter {
        let wrap = wire_list_filter {
            ptr: support::new_leak_vec_ptr(<wire_Filter>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_list_sort_by_0(len: i32) -> *mut wire_list_sort_by {
        let wrap = wire_list_sort_by {
            ptr: support::new_leak_vec_ptr(<wire_SortBy>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_list_synonyms_0(len: i32) -> *mut wire_list_synonyms {
        let wrap = wire_list_synonyms {
            ptr: support::new_leak_vec_ptr(<wire_Synonyms>::new_with_null_ptr(), len),
            len,
        };
        support::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn new_uint_8_list_0(len: i32) -> *mut wire_uint_8_list {
        let ans = wire_uint_8_list {
            ptr: support::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        support::new_leak_box_ptr(ans)
    }

    // Section: related functions

    // Section: impl Wire2Api

    impl Wire2Api<String> for *mut wire_uint_8_list {
        fn wire2api(self) -> String {
            let vec: Vec<u8> = self.wire2api();
            String::from_utf8_lossy(&vec).into_owned()
        }
    }
    impl Wire2Api<Vec<String>> for *mut wire_StringList {
        fn wire2api(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }

    impl Wire2Api<Filter> for *mut wire_Filter {
        fn wire2api(self) -> Filter {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Filter>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<MimirIndexSettings> for *mut wire_MimirIndexSettings {
        fn wire2api(self) -> MimirIndexSettings {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<MimirIndexSettings>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<TermsMatchingStrategy> for *mut i32 {
        fn wire2api(self) -> TermsMatchingStrategy {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<TermsMatchingStrategy>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<u32> for *mut u32 {
        fn wire2api(self) -> u32 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<Box<Filter>> for *mut wire_Filter {
        fn wire2api(self) -> Box<Filter> {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Filter>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Filter> for wire_Filter {
        fn wire2api(self) -> Filter {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Or);
                    Filter::Or(ans.field0.wire2api())
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.And);
                    Filter::And(ans.field0.wire2api())
                },
                2 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Not);
                    Filter::Not(ans.field0.wire2api())
                },
                3 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Exists);
                    Filter::Exists {
                        field: ans.field.wire2api(),
                    }
                },
                4 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.InValues);
                    Filter::InValues {
                        field: ans.field.wire2api(),
                        values: ans.values.wire2api(),
                    }
                },
                5 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.GreaterThan);
                    Filter::GreaterThan {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                6 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.GreaterThanOrEqual);
                    Filter::GreaterThanOrEqual {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                7 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Equal);
                    Filter::Equal {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                8 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.NotEqual);
                    Filter::NotEqual {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                9 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.LessThan);
                    Filter::LessThan {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                10 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.LessThanOrEqual);
                    Filter::LessThanOrEqual {
                        field: ans.field.wire2api(),
                        value: ans.value.wire2api(),
                    }
                },
                11 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Between);
                    Filter::Between {
                        field: ans.field.wire2api(),
                        from: ans.from.wire2api(),
                        to: ans.to.wire2api(),
                    }
                },
                12 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.IsNull);
                    Filter::IsNull {
                        field: ans.field.wire2api(),
                    }
                },
                13 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.IsEmpty);
                    Filter::IsEmpty {
                        field: ans.field.wire2api(),
                    }
                },
                _ => unreachable!(),
            }
        }
    }

    impl Wire2Api<Vec<Filter>> for *mut wire_list_filter {
        fn wire2api(self) -> Vec<Filter> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }
    impl Wire2Api<Vec<SortBy>> for *mut wire_list_sort_by {
        fn wire2api(self) -> Vec<SortBy> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }
    impl Wire2Api<Vec<Synonyms>> for *mut wire_list_synonyms {
        fn wire2api(self) -> Vec<Synonyms> {
            let vec = unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(Wire2Api::wire2api).collect()
        }
    }
    impl Wire2Api<MimirIndexSettings> for wire_MimirIndexSettings {
        fn wire2api(self) -> MimirIndexSettings {
            MimirIndexSettings {
                primary_key: self.primary_key.wire2api(),
                searchable_fields: self.searchable_fields.wire2api(),
                filterable_fields: self.filterable_fields.wire2api(),
                sortable_fields: self.sortable_fields.wire2api(),
                ranking_rules: self.ranking_rules.wire2api(),
                stop_words: self.stop_words.wire2api(),
                synonyms: self.synonyms.wire2api(),
                typos_enabled: self.typos_enabled.wire2api(),
                min_word_size_for_one_typo: self.min_word_size_for_one_typo.wire2api(),
                min_word_size_for_two_typos: self.min_word_size_for_two_typos.wire2api(),
                disallow_typos_on_words: self.disallow_typos_on_words.wire2api(),
                disallow_typos_on_fields: self.disallow_typos_on_fields.wire2api(),
            }
        }
    }

    impl Wire2Api<SortBy> for wire_SortBy {
        fn wire2api(self) -> SortBy {
            match self.tag {
                0 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Asc);
                    SortBy::Asc(ans.field0.wire2api())
                },
                1 => unsafe {
                    let ans = support::box_from_leak_ptr(self.kind);
                    let ans = support::box_from_leak_ptr(ans.Desc);
                    SortBy::Desc(ans.field0.wire2api())
                },
                _ => unreachable!(),
            }
        }
    }
    impl Wire2Api<Synonyms> for wire_Synonyms {
        fn wire2api(self) -> Synonyms {
            Synonyms {
                word: self.word.wire2api(),
                synonyms: self.synonyms.wire2api(),
            }
        }
    }

    impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
        fn wire2api(self) -> Vec<u8> {
            unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    // Section: wire structs

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_StringList {
        ptr: *mut *mut wire_uint_8_list,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_list_filter {
        ptr: *mut wire_Filter,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_list_sort_by {
        ptr: *mut wire_SortBy,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_list_synonyms {
        ptr: *mut wire_Synonyms,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_MimirIndexSettings {
        primary_key: *mut wire_uint_8_list,
        searchable_fields: *mut wire_StringList,
        filterable_fields: *mut wire_StringList,
        sortable_fields: *mut wire_StringList,
        ranking_rules: *mut wire_StringList,
        stop_words: *mut wire_StringList,
        synonyms: *mut wire_list_synonyms,
        typos_enabled: bool,
        min_word_size_for_one_typo: u8,
        min_word_size_for_two_typos: u8,
        disallow_typos_on_words: *mut wire_StringList,
        disallow_typos_on_fields: *mut wire_StringList,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Synonyms {
        word: *mut wire_uint_8_list,
        synonyms: *mut wire_StringList,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_uint_8_list {
        ptr: *mut u8,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter {
        tag: i32,
        kind: *mut FilterKind,
    }

    #[repr(C)]
    pub union FilterKind {
        Or: *mut wire_Filter_Or,
        And: *mut wire_Filter_And,
        Not: *mut wire_Filter_Not,
        Exists: *mut wire_Filter_Exists,
        InValues: *mut wire_Filter_InValues,
        GreaterThan: *mut wire_Filter_GreaterThan,
        GreaterThanOrEqual: *mut wire_Filter_GreaterThanOrEqual,
        Equal: *mut wire_Filter_Equal,
        NotEqual: *mut wire_Filter_NotEqual,
        LessThan: *mut wire_Filter_LessThan,
        LessThanOrEqual: *mut wire_Filter_LessThanOrEqual,
        Between: *mut wire_Filter_Between,
        IsNull: *mut wire_Filter_IsNull,
        IsEmpty: *mut wire_Filter_IsEmpty,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_Or {
        field0: *mut wire_list_filter,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_And {
        field0: *mut wire_list_filter,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_Not {
        field0: *mut wire_Filter,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_Exists {
        field: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_InValues {
        field: *mut wire_uint_8_list,
        values: *mut wire_StringList,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_GreaterThan {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_GreaterThanOrEqual {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_Equal {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_NotEqual {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_LessThan {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_LessThanOrEqual {
        field: *mut wire_uint_8_list,
        value: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_Between {
        field: *mut wire_uint_8_list,
        from: *mut wire_uint_8_list,
        to: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_IsNull {
        field: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Filter_IsEmpty {
        field: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SortBy {
        tag: i32,
        kind: *mut SortByKind,
    }

    #[repr(C)]
    pub union SortByKind {
        Asc: *mut wire_SortBy_Asc,
        Desc: *mut wire_SortBy_Desc,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SortBy_Asc {
        field0: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SortBy_Desc {
        field0: *mut wire_uint_8_list,
    }

    // Section: impl NewWithNullPtr

    pub trait NewWithNullPtr {
        fn new_with_null_ptr() -> Self;
    }

    impl<T> NewWithNullPtr for *mut T {
        fn new_with_null_ptr() -> Self {
            std::ptr::null_mut()
        }
    }

    impl Default for wire_Filter {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Filter {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_Or() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            Or: support::new_leak_box_ptr(wire_Filter_Or {
                field0: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_And() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            And: support::new_leak_box_ptr(wire_Filter_And {
                field0: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_Not() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            Not: support::new_leak_box_ptr(wire_Filter_Not {
                field0: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_Exists() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            Exists: support::new_leak_box_ptr(wire_Filter_Exists {
                field: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_InValues() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            InValues: support::new_leak_box_ptr(wire_Filter_InValues {
                field: core::ptr::null_mut(),
                values: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_GreaterThan() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            GreaterThan: support::new_leak_box_ptr(wire_Filter_GreaterThan {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_GreaterThanOrEqual() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            GreaterThanOrEqual: support::new_leak_box_ptr(wire_Filter_GreaterThanOrEqual {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_Equal() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            Equal: support::new_leak_box_ptr(wire_Filter_Equal {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_NotEqual() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            NotEqual: support::new_leak_box_ptr(wire_Filter_NotEqual {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_LessThan() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            LessThan: support::new_leak_box_ptr(wire_Filter_LessThan {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_LessThanOrEqual() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            LessThanOrEqual: support::new_leak_box_ptr(wire_Filter_LessThanOrEqual {
                field: core::ptr::null_mut(),
                value: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_Between() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            Between: support::new_leak_box_ptr(wire_Filter_Between {
                field: core::ptr::null_mut(),
                from: core::ptr::null_mut(),
                to: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_IsNull() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            IsNull: support::new_leak_box_ptr(wire_Filter_IsNull {
                field: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_Filter_IsEmpty() -> *mut FilterKind {
        support::new_leak_box_ptr(FilterKind {
            IsEmpty: support::new_leak_box_ptr(wire_Filter_IsEmpty {
                field: core::ptr::null_mut(),
            }),
        })
    }

    impl NewWithNullPtr for wire_MimirIndexSettings {
        fn new_with_null_ptr() -> Self {
            Self {
                primary_key: core::ptr::null_mut(),
                searchable_fields: core::ptr::null_mut(),
                filterable_fields: core::ptr::null_mut(),
                sortable_fields: core::ptr::null_mut(),
                ranking_rules: core::ptr::null_mut(),
                stop_words: core::ptr::null_mut(),
                synonyms: core::ptr::null_mut(),
                typos_enabled: Default::default(),
                min_word_size_for_one_typo: Default::default(),
                min_word_size_for_two_typos: Default::default(),
                disallow_typos_on_words: core::ptr::null_mut(),
                disallow_typos_on_fields: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_MimirIndexSettings {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl Default for wire_SortBy {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SortBy {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: core::ptr::null_mut(),
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn inflate_SortBy_Asc() -> *mut SortByKind {
        support::new_leak_box_ptr(SortByKind {
            Asc: support::new_leak_box_ptr(wire_SortBy_Asc {
                field0: core::ptr::null_mut(),
            }),
        })
    }

    #[no_mangle]
    pub extern "C" fn inflate_SortBy_Desc() -> *mut SortByKind {
        support::new_leak_box_ptr(SortByKind {
            Desc: support::new_leak_box_ptr(wire_SortBy_Desc {
                field0: core::ptr::null_mut(),
            }),
        })
    }

    impl NewWithNullPtr for wire_Synonyms {
        fn new_with_null_ptr() -> Self {
            Self {
                word: core::ptr::null_mut(),
                synonyms: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_Synonyms {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    // Section: sync execution mode utility

    #[no_mangle]
    pub extern "C" fn free_WireSyncReturn(ptr: support::WireSyncReturn) {
        unsafe {
            let _ = support::box_from_leak_ptr(ptr);
        };
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
